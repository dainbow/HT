# HT

### О работе

В данном проекте я реализовал хэш-таблицу закрытого типа и оптимизоировал её с помощью ассемблерных вставок/интринсиков/ассемблерных функций

### Этапы работы

##  Первая часть

Написав хэш-таблицу, я измерил время, используемое каждой из функций с помощью callgrind. 

Получились следующие результаты:

![Результаты callgrind без оптимизаций](https://user-images.githubusercontent.com/26509840/162765831-98071741-44d7-4d4f-9204-104462f86de9.png)

Т.к. мы всё-таки делаем ХЭШ-функцию, в первую очередь я решил оптимизировать хэш.

Я знал длину каждого слова, поэтому была придумана оптимизация с названием "Жадный crc", в ней я по максимуму хэшурую слово частями по 8 байт, а после добираю остаток.

## Вторая часть

После первой оптимизации я был удивлён тем, что общее время работы программы не изменилось, поэтому я снова решил обратиться к callgrind

И что же я получил:

![Результаты callgrind после оптимиизации "жадный ctc"](https://user-images.githubusercontent.com/26509840/162766453-e325da7f-419a-4c08-a219-f605c628c295.png)

Несложно понять, что, оказывается, узким местом моей программы являлась фунция main.

Что ж... Проанализировав код данной функции, я понял, что я трачу слишком много времени, сканируя из буффера по 1 байту, поэтому я решил сканировать сразу по 32 байта с помощью avx2 инструций!!! 

А после с помощью битовой магии я начал доставать по 1 слову из буфера, то есть вместо 1 символа за итерацию for'а я обрабатываю по целому слову.

## Третья часть

![Результаты callgrind после ускорения функции main](https://user-images.githubusercontent.com/26509840/162767165-36ca153c-f0c8-44a4-82d2-498608216783.png)

Судя по этим замечательным результатам, оптимизация фунции main прошла успешно, время выполнения программы уменьшилось в полтора раза, но из-за битовых операций нам потребовалось брать двоичный логарифм числа, который я брал с помощью for'ика, перебирая биты от 0 до 31.

Но моя реализация слишком много времени, поэтому я начал искать соответствующую инструцию процессора, и я её нашёл - это bsr!

## Четвёртая часть, заключительная

После всех этих оптимизаций я очень хотел поскорее узнать результат. И инструкция bsr сработала великолепно! Время выполнения программы относительно первой реализации уменьшилось в 2.5 раза!

![Результат после финальной оптимизации](https://user-images.githubusercontent.com/26509840/162768151-1c053a67-07e0-42e9-91ba-1aea39fac98c.png)

Как мы видим, узким местом программы снова стал хэш, но дальнейшая оптимизация не так и нужна...

### Тестирование хэш-функций

Также хочется показать вам результаты тестирования нескольких хэш-функций, по оси X вы можете наблюдать индекс хэша в хэш-таблице, а по оси Y - количество коллизий.

## Тестируемые функции

H1: Всегда возвращаем 1
H2: Возвращаем код первого ascii символа слова
H3: Возвразаем длину слова
H4: Возвращаем сумму ascii кодов слова
H5: H_0 = s[0]; H_i = rol(H_{i-1}) + s[i]
H6: crc32

## Результаты

![H1](https://user-images.githubusercontent.com/26509840/162768440-144869f7-aadc-4a4e-949b-acfa8fb1b209.png)
![H2](https://user-images.githubusercontent.com/26509840/162768447-98192dba-4395-4743-9345-136898861e26.png)
![H3](https://user-images.githubusercontent.com/26509840/162768451-f1271be9-a9da-4e1a-bba5-4c6ad664c6fe.png)
![H4](https://user-images.githubusercontent.com/26509840/162768452-158e9da8-a071-4402-b791-b1b8900b2d65.png)
![H5](https://user-images.githubusercontent.com/26509840/162768453-51ec6ef5-3046-42b1-8821-135560c6d652.png)
![H6](https://user-images.githubusercontent.com/26509840/162768456-a7de5b66-d2c0-453c-a657-371fd43b1036.png)

